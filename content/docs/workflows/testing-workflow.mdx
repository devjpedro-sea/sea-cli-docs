---
title: Workflow de Testes
description: Estratégias e práticas de testes com SEA CLI
---

# Workflow de Testes

Guia completo de estratégias de testes, desde unitários até E2E, usando Jest e Testing Library configurados pelo SEA CLI.

## Pirâmide de Testes

```
        /\
       /  \      E2E (Poucos)
      /____\
     /      \    Integração (Alguns)
    /________\
   /          \  Unitários (Muitos)
  /____________\
```

### Distribuição Recomendada

- **70%** Testes Unitários
- **20%** Testes de Integração
- **10%** Testes E2E

## Testes Unitários

### O Que Testar

```javascript
// Funções puras
export function calculateDiscount(price, percentage) {
  return price * (1 - percentage / 100);
}

// Componentes isolados
export function ProductCard({ product }) {
  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <span>{product.price}</span>
    </div>
  );
}

// Utils e helpers
export function formatCurrency(value) {
  return new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
  }).format(value);
}
```

### Como Testar

```javascript
// test/utils/calculations.test.js
import { calculateDiscount, formatCurrency } from "../src/utils/calculations";

describe("calculateDiscount", () => {
  it("deve calcular desconto de 10%", () => {
    expect(calculateDiscount(100, 10)).toBe(90);
  });

  it("deve calcular desconto de 50%", () => {
    expect(calculateDiscount(200, 50)).toBe(100);
  });

  it("deve retornar preço original com 0%", () => {
    expect(calculateDiscount(100, 0)).toBe(100);
  });

  it("deve tratar valores negativos", () => {
    expect(calculateDiscount(100, -10)).toBe(110);
  });
});

describe("formatCurrency", () => {
  it("deve formatar valor em BRL", () => {
    expect(formatCurrency(100)).toBe("R$ 100,00");
  });

  it("deve formatar valores decimais", () => {
    expect(formatCurrency(99.99)).toBe("R$ 99,99");
  });

  it("deve formatar valores grandes", () => {
    expect(formatCurrency(1234567.89)).toBe("R$ 1.234.567,89");
  });
});
```

### Padrão AAA

```javascript
// Arrange, Act, Assert
describe("ProductCard", () => {
  it("deve renderizar informações do produto", () => {
    // Arrange - Preparar dados
    const mockProduct = {
      id: 1,
      name: "Notebook",
      price: 3000,
    };

    // Act - Executar ação
    const { getByText } = render(<ProductCard product={mockProduct} />);

    // Assert - Verificar resultado
    expect(getByText("Notebook")).toBeInTheDocument();
    expect(getByText("3000")).toBeInTheDocument();
  });
});
```

## Testes de Integração

### Testar Múltiplos Componentes

```javascript
// test/integration/ProductList.integration.test.js
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import ProductList from "../src/components/ProductList";
import { ProductProvider } from "../src/context/ProductContext";

describe("ProductList Integration", () => {
  it("deve filtrar produtos ao digitar", async () => {
    const user = userEvent.setup();

    const mockProducts = [
      { id: 1, name: "Notebook Dell", category: "Eletrônicos" },
      { id: 2, name: "Mouse Logitech", category: "Periféricos" },
      { id: 3, name: "Teclado Mecânico", category: "Periféricos" },
    ];

    render(
      <ProductProvider initialProducts={mockProducts}>
        <ProductList />
      </ProductProvider>
    );

    // Verificar produtos iniciais
    expect(screen.getByText("Notebook Dell")).toBeInTheDocument();
    expect(screen.getByText("Mouse Logitech")).toBeInTheDocument();

    // Digitar filtro
    const searchInput = screen.getByPlaceholderText(/buscar/i);
    await user.type(searchInput, "Mouse");

    // Verificar filtro aplicado
    await waitFor(() => {
      expect(screen.queryByText("Notebook Dell")).not.toBeInTheDocument();
      expect(screen.getByText("Mouse Logitech")).toBeInTheDocument();
      expect(screen.queryByText("Teclado Mecânico")).not.toBeInTheDocument();
    });
  });

  it("deve adicionar produto ao carrinho", async () => {
    const user = userEvent.setup();

    render(
      <ProductProvider>
        <ProductList />
        <Cart />
      </ProductProvider>
    );

    // Adicionar ao carrinho
    const addButton = screen.getAllByText(/adicionar/i)[0];
    await user.click(addButton);

    // Verificar carrinho
    await waitFor(() => {
      expect(screen.getByText(/1 item/i)).toBeInTheDocument();
    });
  });
});
```

### Testar com API Mock

```javascript
// test/integration/api.integration.test.js
import { render, screen, waitFor } from "@testing-library/react";
import { rest } from "msw";
import { setupServer } from "msw/node";
import ProductLoader from "../src/components/ProductLoader";

// Setup MSW server
const server = setupServer(
  rest.get("/o/headless-delivery/v1.0/products", (req, res, ctx) => {
    return res(
      ctx.json({
        items: [
          { id: 1, name: "Produto 1" },
          { id: 2, name: "Produto 2" },
        ],
      })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe("API Integration", () => {
  it("deve carregar produtos da API", async () => {
    render(<ProductLoader />);

    // Verificar loading
    expect(screen.getByText(/carregando/i)).toBeInTheDocument();

    // Aguardar produtos carregarem
    await waitFor(() => {
      expect(screen.getByText("Produto 1")).toBeInTheDocument();
      expect(screen.getByText("Produto 2")).toBeInTheDocument();
    });
  });

  it("deve tratar erro de API", async () => {
    // Mockar erro
    server.use(
      rest.get("/o/headless-delivery/v1.0/products", (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );

    render(<ProductLoader />);

    await waitFor(() => {
      expect(screen.getByText(/erro ao carregar/i)).toBeInTheDocument();
    });
  });
});
```

## Testes E2E

### Cypress Setup

```bash
# Instalar Cypress
npm install --save-dev cypress

# Abrir Cypress
npx cypress open
```

```javascript
// cypress/e2e/product-flow.cy.js
describe("Fluxo de Produto", () => {
  beforeEach(() => {
    cy.visit("http://localhost:8080");
  });

  it("deve navegar e adicionar produto ao carrinho", () => {
    // Navegar para produtos
    cy.contains("Produtos").click();
    cy.url().should("include", "/produtos");

    // Buscar produto
    cy.get('[data-testid="search-input"]').type("Notebook");
    cy.get('[data-testid="search-button"]').click();

    // Verificar resultados
    cy.contains("Notebook").should("be.visible");

    // Adicionar ao carrinho
    cy.contains("Adicionar ao Carrinho").click();

    // Verificar notificação
    cy.contains("Produto adicionado").should("be.visible");

    // Verificar carrinho
    cy.get('[data-testid="cart-count"]').should("contain", "1");
  });

  it("deve finalizar compra", () => {
    // Adicionar produto
    cy.contains("Notebook").click();
    cy.contains("Adicionar ao Carrinho").click();

    // Ir para carrinho
    cy.get('[data-testid="cart-icon"]').click();

    // Verificar produto
    cy.contains("Notebook").should("be.visible");

    // Finalizar
    cy.contains("Finalizar Compra").click();

    // Preencher dados
    cy.get('[name="name"]').type("João Silva");
    cy.get('[name="email"]').type("joao@example.com");
    cy.get('[name="address"]').type("Rua Teste, 123");

    // Confirmar
    cy.contains("Confirmar Pedido").click();

    // Verificar sucesso
    cy.contains("Pedido realizado com sucesso").should("be.visible");
  });
});
```

## TDD (Test-Driven Development)

### Ciclo Red-Green-Refactor

```javascript
// 1. RED - Escrever teste que falha
describe("Cart", () => {
  it("deve adicionar produto ao carrinho", () => {
    const cart = new Cart();
    const product = { id: 1, name: "Notebook", price: 3000 };

    cart.addProduct(product);

    expect(cart.getTotal()).toBe(3000);
    expect(cart.getItems()).toHaveLength(1);
  });
});

// 2. GREEN - Implementar código mínimo que passa
class Cart {
  constructor() {
    this.items = [];
  }

  addProduct(product) {
    this.items.push(product);
  }

  getTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }

  getItems() {
    return this.items;
  }
}

// 3. REFACTOR - Melhorar código mantendo testes verdes
class Cart {
  #items = [];

  addProduct(product) {
    if (!product?.id) {
      throw new Error("Invalid product");
    }
    this.#items.push(product);
  }

  getTotal() {
    return this.#items.reduce((sum, { price = 0 }) => sum + price, 0);
  }

  getItems() {
    return [...this.#items]; // Retorna cópia
  }
}
```

## Estratégias de Mocking

### Mock de Módulos

```javascript
// __mocks__/api.js
export const fetchProducts = jest.fn(() =>
  Promise.resolve([{ id: 1, name: "Mock Product" }])
);

export const createProduct = jest.fn((product) =>
  Promise.resolve({ id: Date.now(), ...product })
);
```

```javascript
// test/ProductManager.test.js
import { fetchProducts, createProduct } from "../src/api";

jest.mock("../src/api");

describe("ProductManager", () => {
  beforeEach(() => {
    fetchProducts.mockClear();
    createProduct.mockClear();
  });

  it("deve buscar produtos", async () => {
    fetchProducts.mockResolvedValueOnce([{ id: 1, name: "Test" }]);

    const products = await fetchProducts();

    expect(fetchProducts).toHaveBeenCalledTimes(1);
    expect(products).toHaveLength(1);
  });
});
```

### Mock de Funções

```javascript
// Mock inline
const mockCallback = jest.fn((x) => x * 2);

[1, 2, 3].forEach(mockCallback);

expect(mockCallback).toHaveBeenCalledTimes(3);
expect(mockCallback).toHaveBeenCalledWith(1);
expect(mockCallback).toHaveBeenCalledWith(2);
expect(mockCallback).toHaveBeenCalledWith(3);

// Verificar ordem de chamadas
expect(mockCallback.mock.calls[0][0]).toBe(1);
expect(mockCallback.mock.calls[1][0]).toBe(2);

// Verificar retornos
expect(mockCallback.mock.results[0].value).toBe(2);
expect(mockCallback.mock.results[1].value).toBe(4);
```

### Spy em Métodos

```javascript
// Spy em console.log
const consoleSpy = jest.spyOn(console, "log").mockImplementation();

myFunction(); // Chama console.log internamente

expect(consoleSpy).toHaveBeenCalledWith("Expected message");

consoleSpy.mockRestore();
```

## Coverage

### Configurar Threshold

```javascript
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
    // Por arquivo
    "./src/utils/*.js": {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90,
    },
  },
};
```

### Executar Coverage

```bash
# Gerar relatório
npm run test:coverage

# Visualizar HTML
open coverage/lcov-report/index.html

# CI mode
npm run test:ci
```

### Interpretar Relatório

```
--------------------------|---------|----------|---------|---------|
File                      | % Stmts | % Branch | % Funcs | % Lines |
--------------------------|---------|----------|---------|---------|
All files                 |   85.23 |    78.45 |   82.11 |   85.67 |
 components               |   90.12 |    85.23 |   88.45 |   90.34 |
  ProductList.jsx         |   95.45 |    92.31 |   94.12 |   95.67 |
  ProductCard.jsx         |   84.23 |    78.56 |   82.45 |   85.12 |
 utils                    |   78.34 |    65.23 |   72.45 |   79.12 |
  api.js                  |   82.12 |    70.45 |   78.23 |   83.45 |
  format.js               |   74.56 |    60.01 |   66.67 |   74.89 |
--------------------------|---------|----------|---------|---------|
```

**Análise:**

- ProductList: Bem testado
- ProductCard: Precisa mais testes
- Utils: Crítico - aumentar coverage

## Organização de Testes

### Estrutura Recomendada

```
modules/produto-portlet/
├── src/
│   ├── components/
│   │   ├── ProductList.jsx
│   │   └── ProductCard.jsx
│   └── utils/
│       └── api.js
├── __tests__/
│   ├── unit/
│   │   ├── components/
│   │   │   ├── ProductList.test.js
│   │   │   └── ProductCard.test.js
│   │   └── utils/
│   │       └── api.test.js
│   ├── integration/
│   │   └── ProductFlow.integration.test.js
│   └── setup/
│       ├── jest.setup.js
│       └── test-utils.js
└── cypress/
    └── e2e/
        └── product.cy.js
```

### Test Utils

```javascript
// __tests__/setup/test-utils.js
import { render } from "@testing-library/react";
import { ProductProvider } from "../../src/context/ProductContext";

export function renderWithProviders(ui, options = {}) {
  const { initialProducts = [], ...renderOptions } = options;

  function Wrapper({ children }) {
    return (
      <ProductProvider initialProducts={initialProducts}>
        {children}
      </ProductProvider>
    );
  }

  return render(ui, { wrapper: Wrapper, ...renderOptions });
}

export * from "@testing-library/react";
export { renderWithProviders as render };
```

```javascript
// Usar em testes
import { render, screen } from "../setup/test-utils";

it("should render with context", () => {
  render(<ProductList />, {
    initialProducts: [{ id: 1, name: "Test" }],
  });

  expect(screen.getByText("Test")).toBeInTheDocument();
});
```

## Scripts de Testes

### package.json

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=__tests__/unit",
    "test:integration": "jest --testPathPattern=__tests__/integration",
    "test:e2e": "cypress run",
    "test:e2e:open": "cypress open",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --maxWorkers=2",
    "test:changed": "jest --onlyChanged",
    "test:related": "jest --findRelatedTests",
    "test:debug": "node --inspect-brk node_modules/.bin/jest --runInBand",
    "test:update": "jest --updateSnapshot"
  }
}
```

## Boas Práticas

<Callout type="tip">
### Recomendações
- **Testes isolados**: Cada teste independente
- **Nomes descritivos**: Use "deve..." ou "should..."
- **AAA pattern**: Arrange, Act, Assert
- **Mock mínimo**: Apenas o necessário
- **Coverage > 80%**: Meta mínima
- **Fast tests**: Testes rápidos (< 1s cada)
- **Determinísticos**: Sempre mesmo resultado
</Callout>

## Troubleshooting

### Testes Lentos

```javascript
// Usar fake timers
jest.useFakeTimers();

it("deve executar callback após delay", () => {
  const callback = jest.fn();

  setTimeout(callback, 1000);

  jest.runAllTimers();

  expect(callback).toHaveBeenCalled();
});

jest.useRealTimers();
```

### Testes Flaky

```javascript
// Usar waitFor para assincronia
await waitFor(
  () => {
    expect(screen.getByText("Loaded")).toBeInTheDocument();
  },
  { timeout: 3000 }
);

// Não usar apenas timeout
await new Promise((resolve) => setTimeout(resolve, 1000)); //
```

### Memory Leaks

```javascript
// Limpar após cada teste
afterEach(() => {
  jest.clearAllMocks();
  cleanup();
});

// Limpar timers
afterEach(() => {
  jest.clearAllTimers();
});
```

## Recursos Relacionados

- [Jest Docs](https://jestjs.io/)
- [Testing Library](https://testing-library.com/)
- [Cypress Docs](https://www.cypress.io/)
- [Development Workflow](/docs/workflows/development-workflow)

---

**Testes garantem qualidade!** Cubra seu código com testes confiáveis e rápidos.
